[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18371825&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Its a branch of computer science that deals with the design, development, testing, and maintenance of software applications. Software engineers apply engineering principles and knowledge of programming languages to build software solutions for end users.

Identify and describe at least three key milestones in the evolution of software engineering.
Mastering machine (1956–1967) - Code development was strongly influenced by outside forces. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. 
Mastering the Process (1968–1982) - the idea was to reduce reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building. 
Mastering the Complexity (1983–1992) - the aim was to enables efficient reuse of object-oriented software and thus improves building software productivity.
Mastering the Communications (1993–2001)- he decentralization of functions and data led to the rapid development and expansion of areas of computing, such as concurrent programming and distributed architectures, which up to then had been limited to a narrower context. In addition to client/server applications, and in general, any distributed system development, there was now a new engineering software discipline called Web engineering 

List and briefly explain the phases of the Software Development Life Cycle.
 Planning - involves defining the software's purpose and scope, much like pinpointing our destination and plotting the best route. We uncover the tasks at hand during this phase and strategize for efficient execution.
 Requirements Analysis - this phase seeks to identify and record the precise requirements of the final users. In this phase, the team is looking to answer, "What are the expectations of our users from our software?" This is called requirements gathering.
Design - this phase is all about building the framework. The development team is responsible for software engineering and outlines the software's functionality and aesthetic. This ultimately results in the software product. The emphasis lies on outlining the software's structure, navigation, user interfaces, and database design. This phase ensures that the software is user-friendly and performs its tasks efficiently.
Coding - this is when engineers and developers get down to business and start converting the software design into tangible code.
Testing -is a stringent quality inspection on a production line. It is when vulnerabilities are uncovered. Software testing involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users. And even identify opportunities for enhancement.
Deployment - After crafting a product with precision, it gets to presented to the users by pushing to the production environment. The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.
Maintenance - this phase is characterized by constant assistance and improvement, which guarantees the software's best possible functioning and longevity and ensures it meets customer expectations.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall is an approach to project management and software development that follows a linear sequence of events. In Waterfall, each phase of the project is gated. Teams cannot advance from one phase of the SDLC to the next until the current phase is complete. Each phase has clearly defined completion criteria. Criteria for the project are generated in the first stage of Waterfall -- the requirements stage -- and codified in documentation. The requirements set forth in the beginning ideally do not change during the course of a development project in this model. Then the Agile is an approach to project management, specifically software development projects, that prioritizes collaboration, continuous delivery and customer feedback. Agile breaks work into iterative steps, which are smaller tasks that can be completed quickly. These iterations are done during sprints. Agile teams complete one sprint before moving onto the next one. Requirements can change at any time in the project based on changing business needs or customer feedback. Future sprints are based on the outcomes of previous sprints.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
**Software Developer Responsibilities**
The typical roles and responsibilities that fall under the software developer job description include:
Consulting with stakeholders, product managers and clients to gather software requirements
Designing and developing the architecture and components for new software programs
Writing high-quality, functional code using the appropriate programming languages
Conducting comprehensive testing and debugging to ensure software quality
Integrating the developed software with third-party programs and existing systems
Deploying finalized applications and software products for end-user access
Maintaining and upgrading current software by fixing bugs and adding enhancements
Creating detailed documentation to explain program functionality and architecture
Collaborating with other teams like UI/UX designers, systems analysts, database experts
Researching and implementing new technologies, tools and best coding practices
Providing mentorship and technical guidance to junior members of the team
Assisting in project planning, estimation, risk analysis and timeline management

**Quality Assurance Engineer Responsibilities**
Collaborate with stakeholders to understand and clarify software requirements.
Create development standards and procedures for the programmers to follow. 
Confirm that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient. 
Develop and execute automation scripts using open-source tools. 

**Project Manager Responsibilities** 
Discuss the project and its requirements with clients and software developers.
Assemble and lead the software development team.
Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.
Supervising each stage of the software development project.
Set the budget and ensure the project adheres to it as closely as possible.
Tracking and communicating information regarding the project milestones, deliverables and change requests.
Deliver the completed software to the client and regularly check its performance. 

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated development environments (IDEs) include functionality that goes beyond text editing. They provide a central interface for common developer tools, making the software development process much more efficient. Developers can start programming new applications quickly instead of manually integrating and configuring different software. They also don't have to learn about all the tools and can instead focus on just one application. they include PyCharm,Aptana Studio 3, PhpStorm, DataGrip 

Version control - also known as source control or revision control - is an important software development practice for tracking and managing changes made to code and other files. It is closely related to source code management. Version control software facilitates coordination, sharing, and collaboration across the entire software development team. It enables teams to work in distributed and asynchronous environments, manage changes and versions of code and artifacts, and resolve merge conflicts and related anomalies. Examples are GitHub, GitLab, Beanstalk, PerForce, Apache Subversion, AWS CodeCommit.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Rapid Advancement of Technology. One of the most significant challenges facing software engineers is the rapid pace of technological advancement. 
Evolving Customer Demands- Software engineers must contend with growing customer demands, working on conceptual projects that require a deep understanding of business concepts and the ability to introduce features that satisfy consumer needs.
Time-to-Market Pressures - 
Skill Shortages and the Great Resignation - 
Technical Implementation Challenges - ensuring security, resolving code conflicts during collaboration, and creating systems that perform reliably under heavy loads.
Cyber- and Data Security -  shifting towards proactive security measures and adopting holistic, AI-powered approaches to adapt to evolving threat landscapes
Software Testing Conflicts - 
Scalability and High Availability

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit tests are very low level and close to the source of an application. They consist in testing individual methods and functions of the classes, components, or modules used by your software. Unit tests are generally quite cheap to automate and can run very quickly by a continuous integration server.

Integration tests verify that different modules or services used by your application work well together. For example, it can be testing the interaction with the database or making sure that microservices work together as expected. These types of tests are more expensive to run as they require multiple parts of the application to be up and running.
Functional tests focus on the business requirements of an application. They only verify the output of an action and do not check the intermediate states of the system when performing that action.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs. Even though generative AI attempts to mimic humans, it requires detailed instructions to create high-quality and relevant output. 

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Tell me about kenya.
tell me about kenya political history
